<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="James Melville" />

<meta name="date" content="2017-07-13" />

<title>Stateful Optimization</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Stateful Optimization</h1>
<h4 class="author"><em>James Melville</em></h4>
<h4 class="date"><em>2017-07-13</em></h4>



<p>By “Stateful” I mean what if we could create an optimizer indepedently of the function it was operating on and be able to pass it around, store it, and get full control over when we pass it data to continue the optimization.</p>
<p>This vignette is about using <code>mize</code> to manually control an optimization externally. Instead of passing <code>mize</code> a function to be optimized from a starting point, then waiting for <code>mize</code> to finish and get back the finished results, you might want to tell <code>mize</code> to optimize for a few steps, then do something with the intermediate results: log the cost, update some parameters, test for some specific convergence criterion, checkpoint the current results, or plot the current state of the result in some custom way. Then, if there’s still more optimization to be done, pass the results back off to <code>mize</code> and get it to crank away for a few more iterations.</p>
<p>This was in fact the inspiration for creating <code>mize</code> in the first place: I wanted access to the sort of optimization routines that the <code>stats::optim</code> function provided, but the lack of control was a deal breaker. One way to try and get around the problem is to only optimize for a few iterations at a time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rb_fg &lt;-<span class="st"> </span><span class="kw">list</span>(
   <span class="dt">fn =</span> <span class="cf">function</span>(x) { <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>  },
   <span class="dt">gr =</span> <span class="cf">function</span>(x) { <span class="kw">c</span>( <span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]),
                          <span class="dv">200</span> <span class="op">*</span><span class="st">        </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>])) })
rb0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>)

par &lt;-<span class="st"> </span>rb0
<span class="cf">for</span> (batch <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>) {
  optim_res &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">optim</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> rb_fg<span class="op">$</span>fn, <span class="dt">gr =</span> rb_fg<span class="op">$</span>gr, 
                            <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">maxit =</span> <span class="dv">10</span>))
  par &lt;-<span class="st"> </span>optim_res<span class="op">$</span>par
  <span class="kw">message</span>(<span class="st">&quot;batch &quot;</span>, batch, <span class="st">&quot; f = &quot;</span>, <span class="kw">formatC</span>(optim_res<span class="op">$</span>value))
}
<span class="co">#&gt; batch 1 f = 1.367</span>
<span class="co">#&gt; batch 2 f = 0.2011</span>
<span class="co">#&gt; batch 3 f = 0.006648</span></code></pre></div>
<p>but even this unsatisfactory work-around causes problems, because you are reinitializing the optimization for with each batch, and losing all the information the optimizer has. In the case of methods like BFGS and CG, this is important for their efficient use. The more control you want, the fewer iterations per batch, but that leads to behavior that approaches steepest descent.</p>
<p>Instead, <code>mize</code> lets you create a stateful optimizer, that you pass to a function, and an updated version of which is returned as part of the return value of the function. This gives you complete control over what to do in between iterations, without sacrificing any of the information the optimizer is using.</p>
<div id="creating-an-optimizer" class="section level2">
<h2>Creating an Optimizer</h2>
<p>To create an optimizer, use the <code>make_mize</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)</code></pre></div>
</div>
<div id="initialize-the-optimizer" class="section level2">
<h2>Initialize the Optimizer</h2>
<p>Before starting the optimization, the optimizer needs to be initialized using the function and starting point. Mainly this is to allow the various methods to preallocate whatever storage they make use of (matrices and vectors) according to the size of the data, as specified by the starting location.</p>
<p>To continue the rosenbrock example from above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">opt &lt;-<span class="st"> </span><span class="kw">mize_init</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg)</code></pre></div>
<div id="a-potential-simplification" class="section level3">
<h3>A potential simplification</h3>
<p>If you have both the starting point and the function to optimize to hand at the point when the optimizer is created, you can provide that to <code>make_mize</code> and it will do the initialization for you:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg, <span class="dt">max_iter =</span> <span class="dv">30</span>)</code></pre></div>
<p>And there is no need to make a separate call to <code>mize_init</code>. However, normally it’s more convenient to handle configuring the optimizer earlier than when the data shows up.</p>
</div>
</div>
<div id="start-optimizing" class="section level2">
<h2>Start optimizing</h2>
<p>Using the batch of ten iteration approach we used with <code>optim</code> is very similar with <code>mize</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">par &lt;-<span class="st"> </span>rb0
iter &lt;-<span class="st"> </span><span class="dv">0</span>
<span class="cf">for</span> (batch <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>) {
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) {
    mize_res &lt;-<span class="st"> </span><span class="kw">mize_step</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> par, <span class="dt">fg =</span> rb_fg)
    par &lt;-<span class="st"> </span>mize_res<span class="op">$</span>par
    opt &lt;-<span class="st"> </span>mize_res<span class="op">$</span>opt
  }
  <span class="kw">message</span>(<span class="st">&quot;batch &quot;</span>, batch, <span class="st">&quot; f = &quot;</span>, <span class="kw">formatC</span>(mize_res<span class="op">$</span>f))
}
<span class="co">#&gt; batch 1 f = 2.604</span>
<span class="co">#&gt; batch 2 f = 0.5568</span>
<span class="co">#&gt; batch 3 f = 0.005003</span></code></pre></div>
<p>The difference here is that you have to do the iterating in batches of 10 manualy yourself, remembering to increment the iteration counter and pass it to <code>mize_step</code>. Plus, the optimizer needs to be updated with the version that was returned from the function.</p>
<div id="return-value-of-mize_step" class="section level3">
<h3>Return value of <code>mize_step</code></h3>
<p>As you can see, with the greater power of <code>mize_step</code> to control the iteration, comes greater responsibility. You also need to decide when to stop iterating. Apart from <code>par</code> and <code>opt</code>, there are some other components to the returned result list which might help:</p>
<ul>
<li><code>f</code> - The function value, if it was calculated at <code>par</code>. For the few methods which don’t do this, you can of course generate it yourself via <code>rb_fg$fn(par)</code>.</li>
<li><code>g</code> - The gradient vector, if it was calculated at <code>par</code>. If it’s not present, then obviously there’s nothing to stop you calculating <code>rb_fg$gr(par)</code> yourself.</li>
<li><code>nf</code> - The number of function evaluations carried out so far (i.e. since initialization). <code>opt</code> is also keeping track of this, and coordinates with <code>mize_step</code>, so you don’t need to manually update this yourself between steps.</li>
<li><code>ng</code> - The number of gradient evaluations carried out so far.</li>
</ul>
<p>You should treat the optimizer, <code>opt</code>, as a black box and not examine its horrific innards, except to check whether <code>opt$error</code> is non-<code>NULL</code>. If it’s anything other than <code>NULL</code>, then this means something really bad has happened during the optimization, most likely a <code>NaN</code> or <code>Inf</code> was calculated in the gradient. This can happen with a very poorly chosen starting point, and a combination of descent method and line search which doesn’t guarantee descent, such as a very aggressive momentum scheme or more likely an adaptive learning rate technique like delta-bar-delta. Monitoring the function value or the size of the change in <code>par</code> between iterations can help spot an imminent divergence.</p>
<p>Taking all that into account, here’s a self-contained example, that removes the now un-necessary batching, does some minor error checking, and keeps track of the best parameters seen so far (although with this combination of optimizer and problem, you don’t have to worry about it):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create the optimizer</span>
opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)

<span class="co"># Pretend we don't have access to the function or starting point until later</span>
rb_fg &lt;-<span class="st"> </span><span class="kw">list</span>(
   <span class="dt">fn =</span> <span class="cf">function</span>(x) { <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>  },
   <span class="dt">gr =</span> <span class="cf">function</span>(x) { <span class="kw">c</span>( <span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]),
                          <span class="dv">200</span> <span class="op">*</span><span class="st">        </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>])) })
rb0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>)

<span class="co"># Initialize</span>
opt &lt;-<span class="st"> </span><span class="kw">mize_init</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg)

<span class="co"># Store the best seen parameters in case something goes wrong</span>
par &lt;-<span class="st"> </span>rb0
par_best &lt;-<span class="st"> </span>par
f_best &lt;-<span class="st"> </span>rb_fg<span class="op">$</span><span class="kw">fn</span>(par_best)

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">30</span>) {
  mize_res &lt;-<span class="st"> </span><span class="kw">mize_step</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> par, <span class="dt">fg =</span> rb_fg)
  par &lt;-<span class="st"> </span>mize_res<span class="op">$</span>par
  opt &lt;-<span class="st"> </span>mize_res<span class="op">$</span>opt
  
  <span class="co"># Do whatever you want with the data at each iteration</span>
  
  <span class="cf">if</span> (opt<span class="op">$</span>is_terminated) {
    <span class="co"># Something bad happened</span>
    <span class="cf">break</span>
  }
  <span class="cf">if</span> (mize_res<span class="op">$</span>f <span class="op">&lt;</span><span class="st"> </span>f_best) {
    f_best &lt;-<span class="st"> </span>mize_res<span class="op">$</span>f
    par_best &lt;-<span class="st"> </span>par
  }
}

<span class="co"># optimized result is in par_best</span>
par_best
<span class="co">#&gt; [1] 0.9294066 0.8642370</span>
f_best
<span class="co">#&gt; [1] 0.005002828</span></code></pre></div>
</div>
</div>
<div id="step-information" class="section level2">
<h2>Step information</h2>
<p>The return value of <code>mize_step</code> provides the function and gradient values. If you would like access to more information, the <code>mize_step_summary</code> function can extract it conveniently:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create optimizer and do one step of optimization as usual</span>
opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg)
par &lt;-<span class="st"> </span>rb0
mize_res &lt;-<span class="st"> </span><span class="kw">mize_step</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> par, <span class="dt">fg =</span> rb_fg)
step_info &lt;-<span class="st"> </span><span class="kw">mize_step_summary</span>(mize_res<span class="op">$</span>opt, mize_res<span class="op">$</span>par, rb_fg, <span class="dt">par_old =</span> par)

<span class="co"># info that's already available in mize_res</span>
step_info<span class="op">$</span>f
<span class="co">#&gt; [1] 19.49933</span>
step_info<span class="op">$</span>ng
<span class="co">#&gt; [1] 3</span>
step_info<span class="op">$</span>nf
<span class="co">#&gt; [1] 3</span>
<span class="co"># and some extra</span>
step_info<span class="op">$</span>step
<span class="co">#&gt; [1] 0.02168573</span>
step_info<span class="op">$</span>alpha
<span class="co">#&gt; [1] 9.31247e-05</span></code></pre></div>
<p><code>mize_step_summary</code> takes <code>opt</code>, <code>par</code> and <code>fg</code> like <code>mize_step</code> does, but also optionally wants a <code>par_old</code> argument. This is the value of <code>par</code> from the previous iteration, from which it calculates the size of the step taken in this iteration.</p>
<p>Information available from the return value of <code>mize_step_summary</code> includes:</p>
<ul>
<li><code>iter</code> The iteration number.</li>
<li><code>f</code> The function value, if it’s available, or if you have set a convergence tolerance that requires its calculation (see below).</li>
<li><code>g2n</code> The gradient l2 (Euclidean) norm, if <code>grad_tol</code> is non-<code>NULL</code> (see the Convergence section for more).</li>
<li><code>ginfn</code> The gradient infinity norm, if <code>ginf_tol</code> is non-<code>NULL</code> (also see the Convergence section for more).</li>
<li><code>nf</code> The number of function evaluations so far over the course of the optimization.</li>
<li><code>ng</code> The number of gradient evaluations so far over the course of the optimization.</li>
<li><code>step</code> The step size of this iteration.</li>
<li><code>alpha</code> The size of the line search value found during the gradient descent stage. This won’t be the same as <code>step</code> even for optimizers that don’t use an extra momentum stage because the total step size is normally the value of <code>alpha</code> multiplied by the magnitude of the gradient.</li>
<li><code>mu</code> If a momentum stage was used, the momentum coefficient.</li>
<li><code>opt</code> The optimizer with updated function and gradient counts, if <code>f</code>, <code>g2n</code>, <code>ginfn</code> was calculated.</li>
</ul>
<p>In many cases, <code>f</code>, <code>g2n</code> and <code>ginfn</code> do not require any recalculation (or aren’t calculated), but to be on the safe side, always reassign <code>opt</code> to the return value from <code>mize_step_summary</code>.</p>
<p>Here’s a modified version of the previous example, where we log out information from <code>mize_step_summary</code>. We’re only going to go for 10 iterations to avoid too much output.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create the optimizer</span>
opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg)

par &lt;-<span class="st"> </span>rb0
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) {
  par_old &lt;-<span class="st"> </span>par
  mize_res &lt;-<span class="st"> </span><span class="kw">mize_step</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> par, <span class="dt">fg =</span> rb_fg)
  par &lt;-<span class="st"> </span>mize_res<span class="op">$</span>par
  opt &lt;-<span class="st"> </span>mize_res<span class="op">$</span>opt

  <span class="co"># step info</span>
  step_info &lt;-<span class="st"> </span><span class="kw">mize_step_summary</span>(opt, par, rb_fg, par_old)
  opt &lt;-<span class="st"> </span>step_info<span class="op">$</span>opt
  <span class="kw">message</span>(<span class="kw">paste</span>(
    <span class="kw">Map</span>(<span class="cf">function</span>(x) { <span class="kw">paste0</span>(x, <span class="st">&quot; = &quot;</span>, <span class="kw">formatC</span>(step_info[[x]])) }, 
        <span class="kw">c</span>(<span class="st">&quot;iter&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;nf&quot;</span>, <span class="st">&quot;ng&quot;</span>, <span class="st">&quot;step&quot;</span>)), 
    <span class="dt">collapse =</span> <span class="st">&quot;, &quot;</span>))
}
<span class="co">#&gt; iter = 1, f = 19.5, nf = 3, ng = 3, step = 0.02169</span>
<span class="co">#&gt; iter = 2, f = 11.57, nf = 4, ng = 4, step = 0.04729</span>
<span class="co">#&gt; iter = 3, f = 4.281, nf = 5, ng = 5, step = 0.09808</span>
<span class="co">#&gt; iter = 4, f = 4.144, nf = 6, ng = 6, step = 0.01427</span>
<span class="co">#&gt; iter = 5, f = 4.14, nf = 7, ng = 7, step = 0.002249</span>
<span class="co">#&gt; iter = 6, f = 4.136, nf = 8, ng = 8, step = 0.002942</span>
<span class="co">#&gt; iter = 7, f = 4.128, nf = 9, ng = 9, step = 0.00557</span>
<span class="co">#&gt; iter = 8, f = 4.114, nf = 10, ng = 10, step = 0.01061</span>
<span class="co">#&gt; iter = 9, f = 4.086, nf = 11, ng = 11, step = 0.02048</span>
<span class="co">#&gt; iter = 10, f = 2.604, nf = 14, ng = 14, step = 0.8382</span></code></pre></div>
</div>
<div id="convergence" class="section level2">
<h2>Convergence</h2>
<p>In the example up until now we have manually looped over 30 iterations and then stopped. More sophisticated stopping criteria is available. Three changes are needed:</p>
<ol style="list-style-type: decimal">
<li>When initializing the optimizer, when passing <code>par</code> and <code>fg</code> to either <code>make_mize</code> or <code>mize_init</code>, also pass termination criteria:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg, <span class="dt">max_iter =</span> <span class="dv">30</span>)
<span class="co"># or</span>
opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)
opt &lt;-<span class="st"> </span><span class="kw">mize_init</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg, <span class="dt">max_iter =</span> <span class="dv">30</span>)</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>At the end of the loop, after calling <code>mize_step_summary</code>, pass the return value to the function <code>mize_check_convergence</code>. This returns an updated version of <code>opt</code> which will indicate if optimization should stop by setting the <code>opt$is_terminated</code> boolean flag:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">step_info &lt;-<span class="st"> </span><span class="kw">mize_step_summary</span>(opt, par, rb_fg, par_old)
opt &lt;-<span class="st"> </span><span class="kw">check_mize_convergence</span>(step_info)</code></pre></div>
<p>Note that you don’t need to manually assign <code>opt</code> to the value that comes from <code>mize_step_summary</code>, as <code>check_mize_convergence</code> handles that.</p>
<ol start="3" style="list-style-type: decimal">
<li>Instead of manually looping with a <code>for</code> loop you can use <code>while (!opt$is_terminated)</code>.</li>
</ol>
<p>Once <code>opt$is_terminated</code> is <code>TRUE</code>, you can find out what caused the optimization by looking at <code>opt$terminate$what</code>. We were using <code>opt$is_terminated</code> before now, where if it was set to <code>TRUE</code> it meant that something awful had occurred, like infinity or NaN in a gradient. <code>check_mize_convergence</code> also uses this flag, but now with an expanded meaning that just indicates optimization should cease, but not necessarily because a catastrophe occurred. It’s still worth checking if <code>opt$is_terminated</code> was set by <code>mize_step</code> if anything that you do in the rest of the loop assumes that the gradient or function value is finite (e.g. comparing it to a real number in a boolean condition).</p>
<p>Apart from just maximum number of iterations, there are a variety of options that relate to convergence. There is a separate vignette which covers these <a href="convergence.html">convergence options</a>, and all the parameters mentioned there can be passed to <code>make_mize</code> and <code>mize_init</code>. Whatever options you use, setting <code>max_iter</code> is a good idea to avoid an infinte loop.</p>
<p>Here’s the example repeated again, this time using <code>check_mize_convergence</code> to control the number of iterations, rather than a <code>for</code> loop:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create the optimizer</span>
opt &lt;-<span class="st"> </span><span class="kw">make_mize</span>(<span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)

rb_fg &lt;-<span class="st"> </span><span class="kw">list</span>(
   <span class="dt">fn =</span> <span class="cf">function</span>(x) { <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>  },
   <span class="dt">gr =</span> <span class="cf">function</span>(x) { <span class="kw">c</span>( <span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]),
                          <span class="dv">200</span> <span class="op">*</span><span class="st">        </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>])) })
rb0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>)

<span class="co"># Initialize and set convergence criteria</span>
opt &lt;-<span class="st"> </span><span class="kw">mize_init</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> rb0, <span class="dt">fg =</span> rb_fg, <span class="dt">max_iter =</span> <span class="dv">30</span>)

<span class="co"># Store the best seen parameters in case something goes wrong</span>
par &lt;-<span class="st"> </span>rb0
par_best &lt;-<span class="st"> </span>par
f_best &lt;-<span class="st"> </span>rb_fg<span class="op">$</span><span class="kw">fn</span>(par_best)

<span class="cf">while</span> (<span class="op">!</span>opt<span class="op">$</span>is_terminated) {
  mize_res &lt;-<span class="st"> </span><span class="kw">mize_step</span>(<span class="dt">opt =</span> opt, <span class="dt">par =</span> par, <span class="dt">fg =</span> rb_fg)
  par &lt;-<span class="st"> </span>mize_res<span class="op">$</span>par
  opt &lt;-<span class="st"> </span>mize_res<span class="op">$</span>opt
  
  <span class="co"># Do whatever you want with the data at each iteration</span>
  
  <span class="cf">if</span> (opt<span class="op">$</span>is_terminated) {
    <span class="co"># Something bad happened</span>
    <span class="cf">break</span>
  }
  <span class="cf">if</span> (mize_res<span class="op">$</span>f <span class="op">&lt;</span><span class="st"> </span>f_best) {
    f_best &lt;-<span class="st"> </span>mize_res<span class="op">$</span>f
    par_best &lt;-<span class="st"> </span>par
  }
  
  step_info &lt;-<span class="st"> </span><span class="kw">mize_step_summary</span>(opt, par, rb_fg, par_old)
  <span class="co"># Do something with the step info if you'd like</span>
  <span class="co"># Check convergence</span>
  opt &lt;-<span class="st"> </span><span class="kw">check_mize_convergence</span>(step_info)
}

<span class="co"># optimized result is in par_best</span>
par_best
<span class="co">#&gt; [1] 0.9294066 0.8642370</span>
f_best
<span class="co">#&gt; [1] 0.005002828</span></code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
