<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="James Melville" />

<meta name="date" content="2019-04-13" />

<title>Convergence</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Convergence</h1>
<h4 class="author">James Melville</h4>
<h4 class="date">2019-04-13</h4>



<p>There are a variety of ways that the optimization can terminate, running the gamut from good (you have reached the minimum and further work is pointless) to bad (the solution diverged and an infinity or NaN turned up in a calculation).</p>
<p>We’ll use the 2D Rosenbrock function for the examples, which has a minimum at <code>c(1, 1)</code>, where the function equals <code>0</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1">rb_fg &lt;-<span class="st"> </span><span class="kw">list</span>(</a>
<a class="sourceLine" id="cb1-2" title="2">   <span class="dt">fn =</span> <span class="cf">function</span>(x) { <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>  },</a>
<a class="sourceLine" id="cb1-3" title="3">   <span class="dt">gr =</span> <span class="cf">function</span>(x) { <span class="kw">c</span>( <span class="dv">-400</span> <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>]) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]),</a>
<a class="sourceLine" id="cb1-4" title="4">                          <span class="dv">200</span> <span class="op">*</span><span class="st">        </span>(x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>])) })</a>
<a class="sourceLine" id="cb1-5" title="5">rb0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>)</a></code></pre></div>
<div id="iteration-tolerance" class="section level2">
<h2>Iteration tolerance</h2>
<p>An obvious way for the optimization to terminate is if you run out of iterations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">max_iter =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">#&gt; [1] &quot;max_iter&quot;</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">#&gt; [1] 10</span></a>
<a class="sourceLine" id="cb2-8" title="8">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">#&gt; [1] 2.552598</span></a>
<a class="sourceLine" id="cb2-10" title="10">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">#&gt; [1] -0.5690157  0.2936478</span></a></code></pre></div>
<p>When comparing different methods, the number of iterations is obviously less important than the amount of actual CPU time you spent. Comparing results with a fixed number of iterations is not a very good idea, because different methods may do a lot more work within an iteration than others. See the section on function and gradient tolerance below.</p>
</div>
<div id="function-tolerance" class="section level2">
<h2>Function tolerance</h2>
<p>There are two ways to specify a function tolerance, based on comparing the difference between consecutive function values. <code>abs_tol</code> measures absolute tolerance.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">max_iter =</span> <span class="dv">100</span>, <span class="dt">abs_tol =</span> <span class="fl">1e-8</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">#&gt; [1] &quot;abs_tol&quot;</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co">#&gt; [1] 4.061025e-10</span></a>
<a class="sourceLine" id="cb3-8" title="8">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">#&gt; [1] 4.606476e-11</span></a>
<a class="sourceLine" id="cb3-10" title="10">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb3-11" title="11"><span class="co">#&gt; [1] 0.9999967 0.9999928</span></a></code></pre></div>
<p>However, relative tolerance is often preferred, because it measures the change in value relative to the size of the values themselves.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">max_iter =</span> <span class="dv">100</span>, <span class="dt">rel_tol =</span> <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"># hit relative tolerance</span></a>
<a class="sourceLine" id="cb4-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">#&gt; [1] &quot;abs_tol&quot;</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">#&gt; [1] 1.06609e-08</span></a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co"># but stopped too early!</span></a>
<a class="sourceLine" id="cb4-11" title="11">res<span class="op">$</span>iter</a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co">#&gt; [1] 37</span></a>
<a class="sourceLine" id="cb4-13" title="13">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">#&gt; [1] 4.521673e-10</span></a>
<a class="sourceLine" id="cb4-15" title="15">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co">#&gt; [1] 0.9999972 0.9999923</span></a></code></pre></div>
<p>In this example we stopped way too early. Even efficient methods like L-BFGS may make little progress on some iterations, so don’t be too aggressive with relative tolerance.</p>
</div>
<div id="gradient-tolerance" class="section level2">
<h2>Gradient tolerance</h2>
<p>Gradient tolerances measure the difference between the size of the gradient on consecutive step. <code>grad_tol</code> uses the 2-norm (sometimes referred to as the Euclidean norm) of the gradient to measure convergence.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">abs_tol =</span> <span class="dv">0</span>, <span class="dt">grad_tol =</span> <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">#&gt; [1] &quot;grad_tol&quot;</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">#&gt; [1] 0.0009378802</span></a>
<a class="sourceLine" id="cb5-9" title="9">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">#&gt; [1] 4.521673e-10</span></a>
<a class="sourceLine" id="cb5-11" title="11">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co">#&gt; [1] 0.9999972 0.9999923</span></a></code></pre></div>
<p>This seems like a good stopping criterion because it is always zero at a minimum, even if the function isn’t. It is also used to compare different methods in Nocedal and Wright’s book. However, it has also been recognized that it is not always reliable, see for instance this <a href="http://dx.doi.org/10.1023/A:1014897230089">paper by Nocedal and co-workers</a>.</p>
<p>Other workers suggest using the infinity norm (the maximum absolute component) of the gradient vector, particularly for larger problems. For example, see this <a href="http://dx.doi.org/10.1137/030601880">conjugate gradient paper by Hager and Zhang</a>. To use the infinity norm, set the <code>ginf_norm</code> parameter.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">rel_tol =</span> <span class="ot">NULL</span>, <span class="dt">abs_tol =</span> <span class="ot">NULL</span>, <span class="dt">ginf_tol =</span> <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">#&gt; [1] &quot;ginf_tol&quot;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">#&gt; [1] 0.0008377527</span></a>
<a class="sourceLine" id="cb6-9" title="9">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co">#&gt; [1] 4.521673e-10</span></a>
<a class="sourceLine" id="cb6-11" title="11">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb6-12" title="12"><span class="co">#&gt; [1] 0.9999972 0.9999923</span></a></code></pre></div>
<p>While the gradient norms aren’t as reliable for checking convergence, they almost never incur any overhead for checking, because the gradient that’s calculated at the end of the iteration for this purpose can nearly always be re-used for the gradient descent calculation at the beginning of the next iteration, whereas the function-based convergence requires the function to be calculated at the end of the iteration and this is not always reused, although for many line search methods it is.</p>
</div>
<div id="step-tolerance" class="section level2">
<h2>Step tolerance</h2>
<p>You can also look out for the change in <code>par</code> itself getting too small:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># set abs_tol to zero to stop it from triggering instead of step_tol</span></a>
<a class="sourceLine" id="cb7-2" title="2">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">abs_tol =</span> <span class="dv">0</span>, <span class="dt">step_tol =</span> .Machine<span class="op">$</span>double.eps)</a>
<a class="sourceLine" id="cb7-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="co">#&gt; [1] &quot;max_iter&quot;</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">#&gt; [1] 100</span></a>
<a class="sourceLine" id="cb7-9" title="9">res<span class="op">$</span>iter</a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">#&gt; [1] 100</span></a>
<a class="sourceLine" id="cb7-11" title="11">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb7-12" title="12"><span class="co">#&gt; [1] 2.383932e-23</span></a>
<a class="sourceLine" id="cb7-13" title="13">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb7-14" title="14"><span class="co">#&gt; [1] 1 1</span></a></code></pre></div>
<p>In most cases, the step tolerance should be a reasonable way to spot convergence. Some optimization methods may allow for a step size of zero for some iterations, preferring to commence the next iteration using the same initial value of <code>par</code>, but with different optimization settings. The step tolerance criterion knows when this sort of “restart” is being attempted, and does not triggered under these conditions.</p>
</div>
<div id="function-and-gradient-count-tolerance" class="section level2">
<h2>Function and gradient count tolerance</h2>
<p>For most problems, the time spent calculating the function and gradient values will drown out any of the house-keeping that individual methods do, so the number of function and gradient evaluations is the usual determinant of how long an optimization takes. You can therefore decide to terminate based on the number of function evaluations:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">max_fn =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">#&gt; [1] &quot;max_fn&quot;</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">#&gt; [1] 10</span></a>
<a class="sourceLine" id="cb8-9" title="9">res<span class="op">$</span>nf</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="co">#&gt; [1] 10</span></a>
<a class="sourceLine" id="cb8-11" title="11">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb8-12" title="12"><span class="co">#&gt; [1] 4.097612</span></a>
<a class="sourceLine" id="cb8-13" title="13">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb8-14" title="14"><span class="co">#&gt; [1] -1.015021  1.049581</span></a></code></pre></div>
<p>Number of gradient evaluations:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">max_gr =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co">#&gt; [1] &quot;max_gr&quot;</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">#&gt; [1] 10</span></a>
<a class="sourceLine" id="cb9-9" title="9">res<span class="op">$</span>ng</a>
<a class="sourceLine" id="cb9-10" title="10"><span class="co">#&gt; [1] 10</span></a>
<a class="sourceLine" id="cb9-11" title="11">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb9-12" title="12"><span class="co">#&gt; [1] 4.097612</span></a>
<a class="sourceLine" id="cb9-13" title="13">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb9-14" title="14"><span class="co">#&gt; [1] -1.015021  1.049581</span></a></code></pre></div>
<p>or both:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">max_fg =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3">res<span class="op">$</span>terminate</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">#&gt; $what</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">#&gt; [1] &quot;max_fg&quot;</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">#&gt; $val</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">#&gt; [1] 10</span></a>
<a class="sourceLine" id="cb10-9" title="9">res<span class="op">$</span>nf</a>
<a class="sourceLine" id="cb10-10" title="10"><span class="co">#&gt; [1] 5</span></a>
<a class="sourceLine" id="cb10-11" title="11">res<span class="op">$</span>ng</a>
<a class="sourceLine" id="cb10-12" title="12"><span class="co">#&gt; [1] 5</span></a>
<a class="sourceLine" id="cb10-13" title="13">res<span class="op">$</span>f</a>
<a class="sourceLine" id="cb10-14" title="14"><span class="co">#&gt; [1] 4.280634</span></a>
<a class="sourceLine" id="cb10-15" title="15">res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb10-16" title="16"><span class="co">#&gt; [1] -1.048507  1.070341</span></a></code></pre></div>
<p>The function and gradient termination criteria are checked both between iterations and during line search. On the assumption that if you specify a maximum number of evaluations, that means these calculations are expensive, <code>mize</code> errs on the side of caution and will sometimes calculate fewer evaluations than you ask for, because it thinks that attempting another iteration will exceed the limit.</p>
</div>
<div id="a-minor-complication-with-convergence-checking" class="section level2">
<h2>A minor complication with convergence checking</h2>
<p>By default, convergence is checked at every iteration. For <code>abs_tol</code> and <code>rel_tol</code>, this means that the function needs to have been evaluated at the current value of <code>par</code>. A lot of optimization methods do this as part of their normal working, so it doesn’t cost very much to do the convergence check. However, not all optimization methods do. If you specify a non-<code>NULL</code> value for <code>rel_tol</code> and <code>abs_tol</code> and the function value isn’t available, it will be calculated. This could, for some methods, add a lot of overhead.</p>
<p>If this is important, then using a gradient-based tolerance will be a better choice.</p>
<p><code>mize</code> internally uses the function value as a way to keep track of the best <code>par</code> found during optimization. If this isn’t available, it will use a gradient norm if that is being calculated. This is less reliable than using function values, but better than nothing. If you turn off all function and gradient tolerances then <code>mize</code> will be unable to return the best set of parameters found over the course of the optimization. Instead, you’ll get the last set of parameters it used.</p>
<p>If convergence checking at every iteration is too much of a burden, you can reduce the frequency with which it is carried out with the <code>check_conv_every</code> parameter:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1">res &lt;-<span class="st"> </span><span class="kw">mize</span>(rb0, rb_fg, <span class="dt">grad_tol =</span> <span class="fl">1e-3</span>, <span class="dt">check_conv_every =</span> <span class="dv">5</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">#&gt; 22:22:12 iter 0 f = 24.2 g2 = 232.9 nf = 1 ng = 1 step = 0 alpha = 0</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">#&gt; 22:22:12 iter 5 f = 4.139 g2 = 1.773 nf = 7 ng = 7 step = 0.002565 alpha = 1</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co">#&gt; 22:22:12 iter 10 f = 2.553 g2 = 11.67 nf = 18 ng = 18 step = 0.04657 alpha = 0.05068</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co">#&gt; 22:22:12 iter 15 f = 1.37 g2 = 6.954 nf = 25 ng = 25 step = 0.0922 alpha = 0.405</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co">#&gt; 22:22:12 iter 20 f = 0.5142 g2 = 3.001 nf = 31 ng = 31 step = 0.1319 alpha = 1</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co">#&gt; 22:22:12 iter 25 f = 0.1203 g2 = 2.398 nf = 37 ng = 37 step = 0.03943 alpha = 0.9408</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co">#&gt; 22:22:12 iter 30 f = 0.009862 g2 = 3.333 nf = 42 ng = 42 step = 0.03554 alpha = 0.1706</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="co">#&gt; 22:22:12 iter 35 f = 2.304e-06 g2 = 0.01537 nf = 47 ng = 47 step = 0.01136 alpha = 1</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="co">#&gt; 22:22:12 iter 40 f = 4.147e-18 g2 = 4.386e-08 nf = 52 ng = 52 step = 6.386e-07 alpha = 1</span></a></code></pre></div>
<p>This also has the side effect of producing less output to the console when <code>verbose = TRUE</code>, because <code>log_every</code> is set to the same value of <code>check_conv_every</code> by default. If you set them to different values, <code>log_every</code> must be an integer multiple of <code>check_conv_every</code>. If it’s not, it will be silently set to be equal to <code>check_conv_every</code>.</p>
<p>In many cases, however, convergence checking every iteration imposes no overhead, so this is a non-issue. The vignette that runs through the methods available in <code>mize</code> mentions where it might be an issue.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
